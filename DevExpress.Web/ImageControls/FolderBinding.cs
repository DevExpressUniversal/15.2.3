#region Copyright (c) 2000-2015 Developer Express Inc.
/*
{*******************************************************************}
{                                                                   }
{       Developer Express .NET Component Library                    }
{                                                                   }
{                                                                   }
{       Copyright (c) 2000-2015 Developer Express Inc.              }
{       ALL RIGHTS RESERVED                                         }
{                                                                   }
{   The entire contents of this file is protected by U.S. and       }
{   International Copyright Laws. Unauthorized reproduction,        }
{   reverse-engineering, and distribution of all or any portion of  }
{   the code contained in this file is strictly prohibited and may  }
{   result in severe civil and criminal penalties and will be       }
{   prosecuted to the maximum extent possible under the law.        }
{                                                                   }
{   RESTRICTIONS                                                    }
{                                                                   }
{   THIS SOURCE CODE AND ALL RESULTING INTERMEDIATE FILES           }
{   ARE CONFIDENTIAL AND PROPRIETARY TRADE                          }
{   SECRETS OF DEVELOPER EXPRESS INC. THE REGISTERED DEVELOPER IS   }
{   LICENSED TO DISTRIBUTE THE PRODUCT AND ALL ACCOMPANYING .NET    }
{   CONTROLS AS PART OF AN EXECUTABLE PROGRAM ONLY.                 }
{                                                                   }
{   THE SOURCE CODE CONTAINED WITHIN THIS FILE AND ALL RELATED      }
{   FILES OR ANY PORTION OF ITS CONTENTS SHALL AT NO TIME BE        }
{   COPIED, TRANSFERRED, SOLD, DISTRIBUTED, OR OTHERWISE MADE       }
{   AVAILABLE TO OTHER INDIVIDUALS WITHOUT EXPRESS WRITTEN CONSENT  }
{   AND PERMISSION FROM DEVELOPER EXPRESS INC.                      }
{                                                                   }
{   CONSULT THE END USER LICENSE AGREEMENT FOR INFORMATION ON       }
{   ADDITIONAL RESTRICTIONS.                                        }
{                                                                   }
{*******************************************************************}
*/
#endregion Copyright (c) 2000-2015 Developer Express Inc.

using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Drawing;
using System.IO;
using System.Linq;
using System.Text;
using System.Web.UI.WebControls;
using DevExpress.Web;
using DevExpress.Web.Internal;
using Action = DevExpress.Web.Internal.ThumbnailAction;
namespace DevExpress.Web {
	public interface ISupportsFolderBinding {
		string ImageSourceFolder { get; }
		string ImageCacheFolder { get; }
		string ImageCacheFolderPropertyDisplayName { get; }
		string Digest { get; set; }
		void ResetDigest();
		void UpdateImageCacheFolder();
		void BeginItemsCreate();
		void CreateAndInitializeItem(AutogeneratedImageUrls images);
		void CompleteItemsCreate();
		IEnumerable<AutogeneratedImageInfo> GetOutputImagesInfo();
		CustomImageProcessingMethod GetCustomImageProcessingMethod(AutogeneratedImageInfo info);
	}
	public interface IImageFileProvider {
		List<String> GetFileNames(string imageSourceFolder);
	}
	public abstract class OriginalImageBase : IDisposable {
		protected System.Drawing.Image InternalImage { get; set; }
		public string FileName { get; private set; }
		public virtual System.Drawing.Image Image { get { return InternalImage; } }
		public OriginalImageBase() {
		}
		public virtual void Dispose() {
			if(InternalImage != null)
				InternalImage.Dispose();
		}
		protected void SetFileName(string fileName) {
			FileName = fileName;
		}
	}
	public class OriginalImage : OriginalImageBase {
		protected Func<System.Drawing.Image> CreateImageMethod { get; private set; }
		public override System.Drawing.Image Image {
			get {
				if(InternalImage == null)
					InternalImage = CreateImageMethod();
				return InternalImage;
			}
		}
		public OriginalImage(Func<System.Drawing.Image> createImageMethod, string fileName) {
			CreateImageMethod = createImageMethod;
			SetFileName(fileName);
		}
	}
	public class BinaryOriginalImage : OriginalImageBase {
		protected MemoryStream Stream { get; private set; }
		public BinaryOriginalImage(byte[] contentBytes) {
			Stream = new MemoryStream(contentBytes);
			InternalImage = System.Drawing.Image.FromStream(Stream);
			SetFileName(CommonUtils.GetMD5Hash(contentBytes) + ImageUtils.GetFileExtension(InternalImage));
		}
		public override void Dispose() {
			base.Dispose();
			Stream.Dispose();
		}
	}
	public class ImageFileInfo {
		protected string RelativeFilePath { get; private set; }
		protected FileInfo FileInfo { get; private set; }
		public ImageFileInfo() {
		}
		public ImageFileInfo(string relativeFilePath) {
			RelativeFilePath = relativeFilePath;
			FileInfo = new FileInfo(MapPath(RelativeFilePath));
		}
		public static bool operator >(ImageFileInfo fi1, ImageFileInfo fi2) {
			return fi1.GetLastWriteTime() > fi2.GetLastWriteTime();
		}
		public static bool operator <(ImageFileInfo fi1, ImageFileInfo fi2) {
			return fi1.GetLastWriteTime() < fi2.GetLastWriteTime();
		}
		public static string MapPath(string relativeFilePath) {
			return System.Web.Hosting.HostingEnvironment.MapPath(relativeFilePath);
		}
		public string GetRelativeFilePath() {
			return RelativeFilePath;
		}
		public string GetAbsoluteFilePath() {
			return FileInfo.FullName;
		}
		public string GetFilePath() {
			return string.Format("{0}?{1}", GetRelativeFilePath(), GetLastWriteTime().ToFileTime().ToString());
		}
		public DateTime GetLastWriteTime() {
			return FileInfo.LastWriteTime;
		}
		public bool IsExists() {
			if(FileInfo == null)
				return false;
			return FileInfo.Exists;
		}
	}
	public interface IFolderBinder {
		string GetSubFolder(AutogeneratedImageInfo info);
		string ImageSourceFolder { get; }
		ISupportsFolderBinding BinderOwner { get; }
		void UpdateImageCacheFolder();
	}
	public class FolderBindingHelper : IFolderBinder {
		#region classed for internal use only
		protected class SimpleImageFileProvider : IImageFileProvider {
			public List<String> GetFileNames(string imageSourceFolder) {
				return ImageUtils.GetImageFiles(imageSourceFolder);
			}
		}
		#endregion
		private const string SubFolderPathPattern = "{0}x{1}.{2}";
		protected ASPxDataWebControl OwnerDataControl {
			get { return Owner as ASPxDataWebControl; }
		}
		protected readonly ISupportsFolderBinding Owner;
		protected readonly IImageFileProvider FileProvider;
		public string ImageSourceFolder { get { return Owner.ImageSourceFolder; } }
		public ISupportsFolderBinding BinderOwner { get { return Owner; } }
		public FolderBindingHelper(ISupportsFolderBinding owner, IImageFileProvider provider = null) {
			Owner = owner;
			FileProvider = provider ?? new SimpleImageFileProvider();
		}
		public AutogeneratedImageUrls CreateThumbnails(byte[] contentBytes, bool overwrite = false) {
			CheckImageCacheFolderAccess();
			IThumbnailCreator<byte[]> thumbnailMaker =
				ImageUtilsHelper.GetThumbnailCreator(this, overwrite);
			return thumbnailMaker.CreateThumbnails(contentBytes);
		}
		public string GetImageUrlFromContentBytes(byte[] contentBytes, AutogeneratedImageInfo info = null) {
			CheckImageCacheFolderAccess();
			IThumbnailCreator<byte[]> thumbnailMaker =
				ImageUtilsHelper.GetThumbnailCreator(this, true);
			return thumbnailMaker.CreateThumbnailImage(contentBytes, info);
		}
		public void CreateItemsFromFolder(bool overwrite = false, bool canGenerateImages = true) {
			if(!CanBindToFolder)
				return;
			if(canGenerateImages)
				CheckImageCacheFolderAccess();
			Owner.BeginItemsCreate();
			IEnumerable<string> fileNames = FileProvider.GetFileNames(ImageSourceFolder);
			IThumbnailCreator<string> thumbnailMaker = ImageUtilsHelper.GetThumbnailCreator(this, canGenerateImages, overwrite);
			foreach(AutogeneratedImageUrls imageUrls in thumbnailMaker.CreateThumbnailsCollection(fileNames))
				Owner.CreateAndInitializeItem(imageUrls);
			Owner.CompleteItemsCreate();
		}
		public string GetSubFolder(AutogeneratedImageInfo info) {
			string result = string.Empty;
			if(info.CreatedFromImage)
				result = RootCacheFolder;
			else
				result = Path.Combine(RootCacheFolder, string.Format(SubFolderPathPattern, info.Size.Width, info.Size.Height, (int)info.SizeMode));
			CheckFolder(result);
			return result;
		}
		public void UpdateImageCacheFolder() {
			Owner.ResetDigest();
			CreateItemsFromFolder(overwrite: true);
		}
		private string rootCacheFolder;
		protected string RootCacheFolder {
			get {
				if(string.IsNullOrEmpty(rootCacheFolder)) {
					rootCacheFolder = Path.Combine(Owner.ImageCacheFolder, CommonUtils.GetMD5Hash(Owner.ImageSourceFolder));
					CheckFolder(rootCacheFolder);
				}
				return rootCacheFolder;
			}
		}
		protected void CheckFolder(string path) {
			string mappedPath = ImageFileInfo.MapPath(path);
			if(!Directory.Exists(mappedPath))
				Directory.CreateDirectory(mappedPath);
		}
		public bool HasFolderDataSource {
			get { return !OwnerDataControl.DesignMode && !string.IsNullOrEmpty(Owner.ImageSourceFolder) && !HasDataSource(); }
		}
		protected bool CanBindToFolder {
			get {
				if(HasFolderDataSource) {
					string newDigest = CreateDigest();
					bool isChanged = newDigest != Owner.Digest;
					if(isChanged)
						Owner.Digest = newDigest;
					return isChanged;
				}
				return false;
			}
		}
		protected bool HasDataSource() {
			return !string.IsNullOrEmpty(OwnerDataControl.DataSourceID) || OwnerDataControl.DataSource != null;
		}
		protected string CreateDigest() {
			string digest = string.Join("|",
				Owner.ImageSourceFolder,
				Owner.ImageCacheFolder,
				Directory.GetLastWriteTime(ImageFileInfo.MapPath(Owner.ImageSourceFolder))
			);
			foreach(AutogeneratedImageInfo imageInfo in Owner.GetOutputImagesInfo())
				digest += string.Format("|{0}|{1}|{2}", imageInfo.Size.Width, imageInfo.Size.Height, (int)imageInfo.SizeMode);
			return CommonUtils.GetMD5Hash(digest);
		}
		private bool isChecked;
		protected void CheckImageCacheFolderAccess() {
			if(!isChecked)
				FileUtils.CheckOrCreateDirectory(Owner.ImageCacheFolder, OwnerDataControl, Owner.ImageCacheFolderPropertyDisplayName);
			isChecked = true;
		}
	}
}
