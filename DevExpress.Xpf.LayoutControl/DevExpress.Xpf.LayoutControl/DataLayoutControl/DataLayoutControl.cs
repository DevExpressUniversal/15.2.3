#region Copyright (c) 2000-2015 Developer Express Inc.
/*
{*******************************************************************}
{                                                                   }
{       Developer Express .NET Component Library                    }
{                                                                   }
{                                                                   }
{       Copyright (c) 2000-2015 Developer Express Inc.              }
{       ALL RIGHTS RESERVED                                         }
{                                                                   }
{   The entire contents of this file is protected by U.S. and       }
{   International Copyright Laws. Unauthorized reproduction,        }
{   reverse-engineering, and distribution of all or any portion of  }
{   the code contained in this file is strictly prohibited and may  }
{   result in severe civil and criminal penalties and will be       }
{   prosecuted to the maximum extent possible under the law.        }
{                                                                   }
{   RESTRICTIONS                                                    }
{                                                                   }
{   THIS SOURCE CODE AND ALL RESULTING INTERMEDIATE FILES           }
{   ARE CONFIDENTIAL AND PROPRIETARY TRADE                          }
{   SECRETS OF DEVELOPER EXPRESS INC. THE REGISTERED DEVELOPER IS   }
{   LICENSED TO DISTRIBUTE THE PRODUCT AND ALL ACCOMPANYING .NET    }
{   CONTROLS AS PART OF AN EXECUTABLE PROGRAM ONLY.                 }
{                                                                   }
{   THE SOURCE CODE CONTAINED WITHIN THIS FILE AND ALL RELATED      }
{   FILES OR ANY PORTION OF ITS CONTENTS SHALL AT NO TIME BE        }
{   COPIED, TRANSFERRED, SOLD, DISTRIBUTED, OR OTHERWISE MADE       }
{   AVAILABLE TO OTHER INDIVIDUALS WITHOUT EXPRESS WRITTEN CONSENT  }
{   AND PERMISSION FROM DEVELOPER EXPRESS INC.                      }
{                                                                   }
{   CONSULT THE END USER LICENSE AGREEMENT FOR INFORMATION ON       }
{   ADDITIONAL RESTRICTIONS.                                        }
{                                                                   }
{*******************************************************************}
*/
#endregion Copyright (c) 2000-2015 Developer Express Inc.

using DevExpress.Entity.Model;
using DevExpress.Mvvm.Native;
using DevExpress.Mvvm.UI.Native.ViewGenerator;
using DevExpress.Mvvm.UI.Native.ViewGenerator.Model;
using DevExpress.Xpf.Core;
using DevExpress.Xpf.Core.Native;
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Data;
namespace DevExpress.Xpf.LayoutControl {
	public enum DataLayoutControlAutoGeneratedItemsLocation { Control, AvailableItems }
	public class DataLayoutControlAutoGeneratedGroupEventArgs : EventArgs {
		public DataLayoutControlAutoGeneratedGroupEventArgs(LayoutGroup group) {
			Group = group;
		}
		public LayoutGroup Group { get; private set; }
	}
	public class DataLayoutControlAutoGeneratingItemEventArgs : CancelEventArgs {
		public DataLayoutControlAutoGeneratingItemEventArgs(string propertyName, Type propertyType, DataLayoutItem item) {
			Item = item;
			PropertyName = propertyName;
			PropertyType = propertyType;
		}
		public DataLayoutItem Item { get; set; }
		public string PropertyName { get; private set; }
		public Type PropertyType { get; private set; }
	}
#if !SILVERLIGHT
#endif
	[DXToolboxBrowsable(DXToolboxItemKind.Free)]
	public class DataLayoutControl : LayoutControl {
		public const string GeneratedItemNamePrefix = "li";
		public static char GroupPathSeparator { get { return LayoutGroupInfoConstants.GroupPathSeparator; } set { LayoutGroupInfoConstants.GroupPathSeparator = value; } }
		public static char BorderlessGroupMarkStart { get { return LayoutGroupInfoConstants.BorderlessGroupMarkStart; } set { LayoutGroupInfoConstants.BorderlessGroupMarkStart = value; } }
		public static char BorderlessGroupMarkEnd { get { return LayoutGroupInfoConstants.BorderlessGroupMarkEnd; } set { LayoutGroupInfoConstants.BorderlessGroupMarkEnd = value; } }
		public static char GroupBoxMarkStart { get { return LayoutGroupInfoConstants.GroupBoxMarkStart; } set { LayoutGroupInfoConstants.GroupBoxMarkStart = value; } }
		public static char GroupBoxMarkEnd { get { return LayoutGroupInfoConstants.GroupBoxMarkEnd; } set { LayoutGroupInfoConstants.GroupBoxMarkEnd = value; } }
		public static char TabbedGroupMarkStart { get { return LayoutGroupInfoConstants.TabbedGroupMarkStart; } set { LayoutGroupInfoConstants.TabbedGroupMarkStart = value; } }
		public static char TabbedGroupMarkEnd { get { return LayoutGroupInfoConstants.TabbedGroupMarkEnd; } set { LayoutGroupInfoConstants.TabbedGroupMarkEnd = value; } }
		public static char HorizontalGroupMark { get { return LayoutGroupInfoConstants.HorizontalGroupMark; } set { LayoutGroupInfoConstants.HorizontalGroupMark = value; } }
		public static char VerticalGroupMark { get { return LayoutGroupInfoConstants.VerticalGroupMark; } set { LayoutGroupInfoConstants.VerticalGroupMark = value; } }
		#region Dependency Properties
		public static readonly DependencyProperty AddColonToItemLabelsProperty =
			DependencyProperty.Register("AddColonToItemLabels", typeof(bool), typeof(DataLayoutControl), new PropertyMetadata(true));
		public static readonly DependencyProperty AutoGeneratedItemsLocationProperty =
			DependencyProperty.Register("AutoGeneratedItemsLocation", typeof(DataLayoutControlAutoGeneratedItemsLocation), typeof(DataLayoutControl),
				new PropertyMetadata((o, e) => ((DataLayoutControl)o).OnAutoGeneratedItemsLocationChanged()));
		public static readonly DependencyProperty CurrentItemProperty =
			DependencyProperty.Register("CurrentItem", typeof(object), typeof(DataLayoutControl),
				new PropertyMetadata((o, e) => ((DataLayoutControl)o).OnCurrentItemChanged(e.OldValue, e.NewValue)));
		public static readonly DependencyProperty IsReadOnlyProperty =
			DependencyProperty.Register("IsReadOnly", typeof(bool), typeof(DataLayoutControl),
				new PropertyMetadata((o, e) => ((DataLayoutControl)o).OnIsReadOnlyChanged()));
		public static readonly DependencyProperty AutoGenerateItemsProperty =
			DependencyProperty.Register("AutoGenerateItems", typeof(bool), typeof(DataLayoutControl),
				new PropertyMetadata(true, (o, e) => ((DataLayoutControl)o).OnAutoGenerateItemsChanged((bool)e.OldValue, (bool)e.NewValue)));			
		#endregion Dependency Properties
#if !SILVERLIGHT
		static DataLayoutControl() {
			OrientationProperty.OverrideMetadata(typeof(DataLayoutControl), new PropertyMetadata(Orientation.Vertical));
		}
#endif
		public DataLayoutControl() {
			GeneratedItems = new List<DataLayoutItem>();
		}
#if !SL
	[DevExpressXpfLayoutControlLocalizedDescription("DataLayoutControlAddColonToItemLabels")]
#endif
		public bool AddColonToItemLabels {
			get { return (bool)GetValue(AddColonToItemLabelsProperty); }
			set { SetValue(AddColonToItemLabelsProperty, value); }
		}
#if !SL
	[DevExpressXpfLayoutControlLocalizedDescription("DataLayoutControlAutoGeneratedItemsLocation")]
#endif
		public DataLayoutControlAutoGeneratedItemsLocation AutoGeneratedItemsLocation {
			get { return (DataLayoutControlAutoGeneratedItemsLocation)GetValue(AutoGeneratedItemsLocationProperty); }
			set { SetValue(AutoGeneratedItemsLocationProperty, value); }
		}
#if !SL
	[DevExpressXpfLayoutControlLocalizedDescription("DataLayoutControlController")]
#endif
		public new DataLayoutControlController Controller { get { return (DataLayoutControlController)base.Controller; } }
#if !SL
	[DevExpressXpfLayoutControlLocalizedDescription("DataLayoutControlCurrentItem")]
#endif
		public object CurrentItem {
			get { return (object)GetValue(CurrentItemProperty); }
			set { SetValue(CurrentItemProperty, value); }
		}
#if !SL
	[DevExpressXpfLayoutControlLocalizedDescription("DataLayoutControlIsReadOnly")]
#endif
		public bool IsReadOnly {
			get { return (bool)GetValue(IsReadOnlyProperty); }
			set { SetValue(IsReadOnlyProperty, value); }
		}
		public bool AutoGenerateItems {
			get { return (bool)GetValue(AutoGenerateItemsProperty); }
			set { SetValue(AutoGenerateItemsProperty, value); }
		}
		public event EventHandler<DataLayoutControlAutoGeneratedGroupEventArgs> AutoGeneratedGroup;
		public event EventHandler AutoGeneratedUI;
		public event EventHandler<DataLayoutControlAutoGeneratingItemEventArgs> AutoGeneratingItem;
		public event ValueChangedEventHandler<object> CurrentItemChanged;
		protected override PanelControllerBase CreateController() {
			return new DataLayoutControlController(this);
		}
#if SILVERLIGHT
		protected override Orientation GetDefaultOrientation() {
			return Orientation.Vertical;
		}
#endif
		protected void ClearItem(DataLayoutItem item) {
#if !SILVERLIGHT
			if (!string.IsNullOrEmpty(item.Name) && FindName(item.Name) == item)	
				UnregisterName(item.Name);
#endif
			item.Name = "";
			item.ClearValue(FrameworkElement.DataContextProperty);
			item.ClearValue(LayoutItem.AddColonToLabelProperty);
			item.DataLayoutControl = null;
		}
		protected void ClearUI() {
			DeleteChildren();
			AvailableItems.BeginUpdate();
			foreach (DataLayoutItem item in GeneratedItems)
				AvailableItems.Remove(item);
			AvailableItems.EndUpdate();
			GeneratedItems.ForEach(ClearItem);
			GeneratedItems.Clear();
		}
		protected internal virtual DataLayoutItem CreateItem() {
			return new DataLayoutItem();
		}
		protected virtual LayoutGroupInfo CreateRootGroupInfo() {
			return new LayoutGroupInfo(null, GroupView.Group, Orientation);
		}
		protected internal DataLayoutItem GenerateItem(Type valueType, IEdmPropertyInfo propertyInfo, Func<DataLayoutItem> createItem = null) {
			DataLayoutItem item = createItem.Return(x => x(), () => CreateItem());
			if (propertyInfo != null)
				GenerateItemName(item, propertyInfo.Name);
			item.Binding = new Binding(propertyInfo != null ? propertyInfo.Name : string.Empty);
			item.SetBinding(FrameworkElement.DataContextProperty,
				new Binding { Source = this, Path = new PropertyPath(CurrentItemProperty), Mode = BindingMode.OneWay });
			item.SetBinding(LayoutItem.AddColonToLabelProperty,
				new Binding { Source = this, Path = new PropertyPath(AddColonToItemLabelsProperty), Mode = BindingMode.OneWay });
			OnAutoGeneratingItem(valueType, propertyInfo, ref item);
			if (item != null) {
				GeneratedItems.Add(item);
				item.DataLayoutControl = this;
			}
			return item;
		}
		protected void GenerateItemName(DataLayoutItem item, string propertyName) {
			if (!this.IsInVisualTree())
				return;
			item.Name = GetUniqueName(GeneratedItemNamePrefix + propertyName);
#if !SILVERLIGHT
			RegisterName(item.Name, item);
#endif
		}
		protected void GenerateUI() {
			if (CurrentItemType.IsSimple())
				GenerateUIForSimpleType();
			else
				GenerateUIForComplexType();
			OnAutoGeneratedUI();
		}
		protected virtual void GenerateUIForComplexType() {
			AvailableItems.BeginUpdate();
			RuntimeEditingContext context = new RuntimeEditingContext(this);
			var properties = GetCurrentItemTypeVisibleProperties();
			var groupGenerator = new LayoutGroupGenerator(context.GetRoot(), 
				x => context.CreateModelItem(((LayoutGroup)x.GetCurrentValue()).CreateGroup(), null), 
				x => OnAutoGeneratedGroup((LayoutGroup)x.GetCurrentValue()), 
				x => new DataLayoutControlGenerator(this, y => ((LayoutGroup)x.GetCurrentValue()).Children.Add(y)));
			EditorsSource.GenerateEditors(CreateRootGroupInfo(), properties, groupGenerator, 
				new DataLayoutControlGenerator(this, x => AvailableItems.Add(x)), 
				GenerateEditorOptions.ForLayoutRuntime(), AutoGeneratedItemsLocation == DataLayoutControlAutoGeneratedItemsLocation.AvailableItems, true, null, false);
			AvailableItems.EndUpdate();
		}
		protected virtual void GenerateUIForSimpleType() {
			DataLayoutItem item = GenerateItem(CurrentItemType, null);
			if (item != null)
				if (AutoGeneratedItemsLocation == DataLayoutControlAutoGeneratedItemsLocation.Control)
					Children.Add(item);
				else
					AvailableItems.Add(item);
		}
		protected Type GetCurrentItemType(object currentItem) {
			return currentItem != null ? currentItem.GetType() : null;
		}
		protected virtual IEnumerable<IEdmPropertyInfo> GetCurrentItemTypeSupportedProperties() {
			IEntityProperties typeInfo = new ReflectionEntityProperties(TypeDescriptor.GetProperties(CurrentItem).Cast<PropertyDescriptor>(), CurrentItemType, true);
			return typeInfo.AllProperties;
		}
		protected virtual IEnumerable<IEdmPropertyInfo> GetCurrentItemTypeVisibleProperties() {
			return EditorsGeneratorBase.GetFilteredAndSortedProperties(GetCurrentItemTypeSupportedProperties(), false, false, LayoutType.DataForm);
		}
		protected string GetUniqueName(string baseName) {
			string result = baseName;
			int counter = 0;
			while (FindName(result) != null)
				result = baseName + (++counter).ToString();
			return result;
		}
		protected virtual void OnAutoGeneratedItemsLocationChanged() {
			UpdateUI();
		}
		protected virtual void OnAutoGeneratedGroup(LayoutGroup group) {
			if (AutoGeneratedGroup != null)
				AutoGeneratedGroup(this, new DataLayoutControlAutoGeneratedGroupEventArgs(group));
		}
		protected virtual void OnAutoGeneratedUI() {
			if (AutoGeneratedUI != null)
				AutoGeneratedUI(this, EventArgs.Empty);
		}
		protected virtual void OnAutoGeneratingItem(Type valueType, IEdmPropertyInfo property, ref DataLayoutItem item) {
			if (AutoGeneratingItem == null)
				return;
			var args = new DataLayoutControlAutoGeneratingItemEventArgs(property != null ? property.Name : null, valueType, item);
			AutoGeneratingItem(this, args);
			item = args.Item;
			if (args.Cancel)
				item = null;
		}
		Action currentItemChangedAction;
		protected virtual void OnCurrentItemChanged(object oldValue, object newValue) {
			currentItemChangedAction = () => {
				if(GetCurrentItemType(newValue) != GetCurrentItemType(oldValue)) UpdateUI();									
				if(CurrentItemChanged != null)
					CurrentItemChanged(this, new ValueChangedEventArgs<object>(oldValue, newValue));
			};
			if(IsInitialized) {
				currentItemChangedAction();
				currentItemChangedAction = null;
			}
		}
		protected override void OnInitialized(EventArgs e) {
			base.OnInitialized(e);
			if(currentItemChangedAction != null) {
				currentItemChangedAction();
				currentItemChangedAction = null;
			}
		}
		protected virtual void OnIsReadOnlyChanged() {
			GeneratedItems.ForEach(item => item.OnDataLayoutControlIsReadOnlyChanged());
		}
		protected virtual void OnAutoGenerateItemsChanged(bool oldValue, bool newValue) {
			if(this.IsInDesignTool()) {
				ClearUI();
				if(Root != null)
					Root.ModelChanged(new LayoutControlModelPropertyChangedEventArgs(this, "AutoGenerateItems", AutoGenerateItemsProperty));				
			}
			if(newValue) UpdateUI();
		}
		protected void UpdateUI() {
			if(!AutoGenerateItems) return;
			using(updateLocker.Lock()) {
				ClearUI();
				if(CurrentItem != null)
					GenerateUI();
			}
		}
		protected Type CurrentItemType { get { return GetCurrentItemType(CurrentItem); } }
		protected List<DataLayoutItem> GeneratedItems { get; private set; }
		Locker updateLocker = new Locker();
		protected override void OnVisualChildrenChanged(DependencyObject visualAdded, DependencyObject visualRemoved) {
			base.OnVisualChildrenChanged(visualAdded, visualRemoved);
			if(AutoGenerateItems && this.IsInDesignTool() && !updateLocker) {
				UIElement elementAdded = visualAdded as UIElement;
				if(elementAdded != null && !IsInternalElement(elementAdded)) {
					UpdateUI();
				}
			}
		}
	}
	public class DataLayoutControlController : LayoutControlController {
		public DataLayoutControlController(ILayoutControl control) : base(control) { }
		#region Design-time Support
		protected override bool ForwardDesignTimeInput { get { return (Control as DataLayoutControl).Return(x => !x.AutoGenerateItems, () => false); } }
		#endregion Design-time Support
	}
}
