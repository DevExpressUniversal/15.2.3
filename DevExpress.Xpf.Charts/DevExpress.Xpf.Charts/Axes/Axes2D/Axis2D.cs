#region Copyright (c) 2000-2015 Developer Express Inc.
/*
{*******************************************************************}
{                                                                   }
{       Developer Express .NET Component Library                    }
{                                                                   }
{                                                                   }
{       Copyright (c) 2000-2015 Developer Express Inc.              }
{       ALL RIGHTS RESERVED                                         }
{                                                                   }
{   The entire contents of this file is protected by U.S. and       }
{   International Copyright Laws. Unauthorized reproduction,        }
{   reverse-engineering, and distribution of all or any portion of  }
{   the code contained in this file is strictly prohibited and may  }
{   result in severe civil and criminal penalties and will be       }
{   prosecuted to the maximum extent possible under the law.        }
{                                                                   }
{   RESTRICTIONS                                                    }
{                                                                   }
{   THIS SOURCE CODE AND ALL RESULTING INTERMEDIATE FILES           }
{   ARE CONFIDENTIAL AND PROPRIETARY TRADE                          }
{   SECRETS OF DEVELOPER EXPRESS INC. THE REGISTERED DEVELOPER IS   }
{   LICENSED TO DISTRIBUTE THE PRODUCT AND ALL ACCOMPANYING .NET    }
{   CONTROLS AS PART OF AN EXECUTABLE PROGRAM ONLY.                 }
{                                                                   }
{   THE SOURCE CODE CONTAINED WITHIN THIS FILE AND ALL RELATED      }
{   FILES OR ANY PORTION OF ITS CONTENTS SHALL AT NO TIME BE        }
{   COPIED, TRANSFERRED, SOLD, DISTRIBUTED, OR OTHERWISE MADE       }
{   AVAILABLE TO OTHER INDIVIDUALS WITHOUT EXPRESS WRITTEN CONSENT  }
{   AND PERMISSION FROM DEVELOPER EXPRESS INC.                      }
{                                                                   }
{   CONSULT THE END USER LICENSE AGREEMENT FOR INFORMATION ON       }
{   ADDITIONAL RESTRICTIONS.                                        }
{                                                                   }
{*******************************************************************}
*/
#endregion Copyright (c) 2000-2015 Developer Express Inc.

using System;
using System.ComponentModel;
using System.Collections.Generic;
using System.Windows;
using System.Windows.Media;
using System.Windows.Shapes;
using DevExpress.Charts.Native;
using DevExpress.Utils.Serializing;
using DevExpress.Xpf.Utils;
using DevExpress.Xpf.Core.Native;
using DevExpress.Xpf.Charts.Native;
using DevExpress.Utils;
using System.Windows.Markup;
namespace DevExpress.Xpf.Charts {
	internal enum AxisPosition {
		Left,
		Top,
		Right,
		Bottom
	}
	public enum AxisAlignment {
		Near,
		Far
	}
	public enum AxisLabelVisibilityMode {
		Default,
		AutoGeneratedAndCustom
	}
	public abstract class Axis2D : Axis, ILineOwner, ICrosshairAxis, IResolveLabelsOverlappingAxis, ITickmarksOwner, ITransformable, ISupportVisibilityControlElement {
		static readonly DependencyPropertyKey ConstantLinesBehindPropertyKey = DependencyPropertyManager.RegisterReadOnly("ConstantLinesBehind",
			typeof(ConstantLineCollection), typeof(Axis2D), new PropertyMetadata());
		static readonly DependencyPropertyKey ConstantLinesInFrontPropertyKey = DependencyPropertyManager.RegisterReadOnly("ConstantLinesInFront",
			typeof(ConstantLineCollection), typeof(Axis2D), new PropertyMetadata());
		static readonly DependencyPropertyKey StripsPropertyKey = DependencyPropertyManager.RegisterReadOnly("Strips", typeof(StripCollection), typeof(Axis2D), new PropertyMetadata());
		static readonly DependencyPropertyKey CustomLabelsPropertyKey = DependencyPropertyManager.RegisterReadOnly("CustomLabels", typeof(CustomAxisLabelCollection), typeof(Axis2D), new PropertyMetadata());
		static readonly DependencyPropertyKey VisibilityInPanesPropertyKey = DependencyPropertyManager.RegisterReadOnly("VisibilityInPanes",
			typeof(VisibilityInPaneCollection), typeof(Axis2D), new PropertyMetadata());
		public static readonly DependencyProperty ConstantLinesBehindProperty = ConstantLinesBehindPropertyKey.DependencyProperty;
		public static readonly DependencyProperty ConstantLinesInFrontProperty = ConstantLinesInFrontPropertyKey.DependencyProperty;
		public static readonly DependencyProperty StripsProperty = StripsPropertyKey.DependencyProperty;
		public static readonly DependencyProperty CustomLabelsProperty = CustomLabelsPropertyKey.DependencyProperty;
		public static readonly DependencyProperty VisibilityInPanesProperty = VisibilityInPanesPropertyKey.DependencyProperty;
		public static readonly DependencyProperty VisibleProperty = DependencyPropertyManager.Register("Visible", typeof(bool?), typeof(Axis2D), new PropertyMetadata(null, ChartElementHelper.Update));
		public static readonly DependencyProperty AlignmentProperty = DependencyPropertyManager.Register("Alignment",
			typeof(AxisAlignment), typeof(Axis2D), new PropertyMetadata(AxisAlignment.Near, ChartElementHelper.Update));
		public static readonly DependencyProperty ReverseProperty = DependencyPropertyManager.Register("Reverse", typeof(bool), typeof(Axis2D), new PropertyMetadata(false, ReversePropertyChanged));
		[Obsolete(ObsoleteMessages.ScrollingRangeProperty)]
		public static readonly DependencyProperty ScrollingRangeProperty;
		public static readonly DependencyProperty ThicknessProperty = DependencyPropertyManager.Register("Thickness",
			typeof(int), typeof(Axis2D), new PropertyMetadata(1, ChartElementHelper.Update), ValidateThickness);
		public static readonly DependencyProperty BrushProperty = DependencyPropertyManager.Register("Brush", typeof(Brush), typeof(Axis2D));
		public static readonly DependencyProperty TickmarksVisibleProperty = DependencyPropertyManager.Register("TickmarksVisible",
			typeof(bool), typeof(Axis2D), new PropertyMetadata(true, ChartElementHelper.Update));
		public static readonly DependencyProperty TickmarksMinorVisibleProperty = DependencyPropertyManager.Register("TickmarksMinorVisible",
			typeof(bool), typeof(Axis2D), new PropertyMetadata(true, ChartElementHelper.Update));
		public static readonly DependencyProperty TickmarksThicknessProperty = DependencyPropertyManager.Register("TickmarksThickness",
			typeof(int), typeof(Axis2D), new PropertyMetadata(1, ChartElementHelper.Update), ValidateTickmarksThickness);
		public static readonly DependencyProperty TickmarksMinorThicknessProperty = DependencyPropertyManager.Register("TickmarksMinorThickness",
			typeof(int), typeof(Axis2D), new PropertyMetadata(1, ChartElementHelper.Update), ValidateTickmarksThickness);
		public static readonly DependencyProperty TickmarksLengthProperty = DependencyPropertyManager.Register("TickmarksLength",
			typeof(int), typeof(Axis2D), new PropertyMetadata(5, ChartElementHelper.Update), ValidateTickmarksLength);
		public static readonly DependencyProperty TickmarksMinorLengthProperty = DependencyPropertyManager.Register("TickmarksMinorLength",
			typeof(int), typeof(Axis2D), new PropertyMetadata(2, ChartElementHelper.Update), ValidateTickmarksLength);
		public static readonly DependencyProperty TickmarksCrossAxisProperty = DependencyPropertyManager.Register("TickmarksCrossAxis",
			typeof(bool), typeof(Axis2D), new PropertyMetadata(false, ChartElementHelper.Update));
		public static readonly DependencyProperty CrosshairAxisLabelOptionsProperty = DependencyPropertyManager.Register("CrosshairAxisLabelOptions",
			typeof(CrosshairAxisLabelOptions), typeof(Axis2D), new PropertyMetadata(null, CrosshairAxisLabelOptionsPropertyChanged));
		public static readonly DependencyProperty CrosshairLabelTemplateProperty = DependencyPropertyManager.Register("CrosshairLabelTemplate",
			typeof(DataTemplate), typeof(Axis2D), new PropertyMetadata(null));
		public static readonly DependencyProperty ResolveOverlappingOptionsProperty = DependencyPropertyManager.RegisterAttached("ResolveOverlappingOptions",
			typeof(AxisLabelResolveOverlappingOptions), typeof(Axis2D), new PropertyMetadata(AxisLabel.ResolveOverlappingOptionsPropertyChanged));
		public static readonly DependencyProperty LabelVisibilityModeProperty = DependencyPropertyManager.Register("LabelVisibilityMode",
			typeof(AxisLabelVisibilityMode), typeof(Axis2D), new PropertyMetadata(AxisLabelVisibilityMode.Default, ChartElementHelper.Update));
		public static readonly DependencyProperty VisualRangeProperty = DependencyPropertyManager.Register("VisualRange", typeof(Range), typeof(Axis2D), new PropertyMetadata(VisualRangePropertyChanged));
		[Obsolete(ObsoleteMessages.Axis2DCrosshairLabelPatternProperty)]
		public static readonly DependencyProperty CrosshairLabelPatternProperty = DependencyPropertyManager.Register("CrosshairLabelPattern",
			typeof(string), typeof(Axis2D), new PropertyMetadata("", CrosshairLabelPatternPropertyChanged));
		[Obsolete(ObsoleteMessages.Axis2DCrosshairLabelVisibilityProperty)]
		public static readonly DependencyProperty CrosshairLabelVisibilityProperty = DependencyPropertyManager.Register("CrosshairLabelVisibility",
			typeof(bool?), typeof(Axis2D), new PropertyMetadata(null, CrosshairLabelVisibilityPropertyChanged));
		static void CrosshairAxisLabelOptionsPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e) {
			CrosshairAxisLabelOptions crosshairAxisLabelOptions = e.NewValue as CrosshairAxisLabelOptions;
			Axis2D axis = d as Axis2D;
			if (axis != null && crosshairAxisLabelOptions != null && (crosshairAxisLabelOptions.Owner == null || crosshairAxisLabelOptions.Owner != axis))
				crosshairAxisLabelOptions.Owner = axis;
		}
		static void ReversePropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e) {
			Axis2D axis = d as Axis2D;
			if (axis != null) {
				axis.ReverseInternal = (bool)e.NewValue;
				ChartElementHelper.Update(d, e);
				axis.RangeLimitsUpdated();
			}
		}
		[Obsolete]
		static void ScrollingRangePropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e) {
			Axis2D axis = d as Axis2D;
			if (axis != null) {
				AxisRange range = e.NewValue as AxisRange;
				if (range == null) {
					axis.actualScrollingRange = new AxisRange();
					e = new DependencyPropertyChangedEventArgs(e.Property, e.OldValue, axis.actualScrollingRange);
				}
				else {
					range.UpdateMinMaxValues(axis);
					axis.actualScrollingRange = range;
				}
			}
			ChartElementHelper.ChangeOwnerAndUpdate(d, e);
		}
		static bool ValidateThickness(object thickness) {
			return (int)thickness >= 0;
		}
		static bool ValidateTickmarksThickness(object thickness) {
			return (int)thickness > 0;
		}
		static bool ValidateTickmarksLength(object length) {
			return (int)length > 0;
		}
		static void CrosshairLabelPatternPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e) {
			Axis2D axis = d as Axis2D;
			if (axis != null)
				axis.ActualCrosshairAxisLabelOptions.Pattern = (string)e.NewValue;
		}
		static void CrosshairLabelVisibilityPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e) {
			Axis2D axis = d as Axis2D;
			if (axis != null)
				axis.ActualCrosshairAxisLabelOptions.Visibility = (bool?)e.NewValue;
		}
		static void VisualRangePropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e) {
			Axis2D axis = d as Axis2D;
			if (axis != null) {
				Range range = e.NewValue as Range;
				if (range == null) {
					range = new Range();
					axis.VisualRangeData.Reset(false);
					e = new DependencyPropertyChangedEventArgs(e.Property, e.OldValue, range);
				}
				range.SetRangeData(axis.VisualRangeData);
				axis.ActualVisualRange = range;
				axis.CreateMediator();
			}
			ChartElementHelper.ChangeOwnerAndUpdate(d, e);
		}
		[
		Category(Categories.Behavior),
		XtraSerializableProperty(XtraSerializationVisibility.Content, true)
		]
		public static AxisLabelResolveOverlappingOptions GetResolveOverlappingOptions(AxisLabel label) {
			return (AxisLabelResolveOverlappingOptions)label.GetValue(ResolveOverlappingOptionsProperty);
		}
		public static void SetResolveOverlappingOptions(AxisLabel label, AxisLabelResolveOverlappingOptions value) {
			label.SetValue(ResolveOverlappingOptionsProperty, value);
		}
		readonly ActualAxisVisibilityInPanes actualVisibilityInPanes;
		[Obsolete]
		AxisRange actualScrollingRange;
		Range actualVisualRange;
		#region ICrosshairAxis
		string ICrosshairAxis.LabelPattern { get { return ActualCrosshairAxisLabelOptions.Pattern; } }
		bool ICrosshairAxis.LabelVisible { get { return ActualCrosshairLabelVisibility; } }
		#endregion
		#region IPatternHolder
		string IPatternHolder.PointPattern { get { return ActualCrosshairAxisLabelOptions.Pattern; } }
		PatternDataProvider IPatternHolder.GetDataProvider(PatternConstants patternConstant) {
			return new AxisPatternDataProvider();
		}
		#endregion
		bool ActualCrosshairLabelVisibility {
			get {
				if (ActualCrosshairAxisLabelOptions.Visibility.HasValue)
					return ActualCrosshairAxisLabelOptions.Visibility.Value;
				if (Diagram2D == null || Diagram2D.ChartControl == null)
					return false;
				CrosshairOptions options = Diagram2D.ChartControl.ActualCrosshairOptions;
				return IsValuesAxis ? options.ShowValueLabels : options.ShowArgumentLabels;
			}
		}
#if !SL
	[DevExpressXpfChartsLocalizedDescription("Axis2DActualScrollingRange")]
#endif
		[
		Obsolete(ObsoleteMessages.ActualScrollingRangeProperty),
		EditorBrowsable(EditorBrowsableState.Never)
		]
		public AxisRange ActualScrollingRange { get { return actualScrollingRange; } }
		[Browsable(false), Description("")]
		public Range ActualVisualRange { get { return actualVisualRange; } protected set { actualVisualRange = value; } }
		[
#if !SL
	DevExpressXpfChartsLocalizedDescription("Axis2DConstantLinesBehind"),
#endif
		Category(Categories.Elements),
		XtraSerializableProperty(XtraSerializationVisibility.Collection, true, false, true)
		]
		public ConstantLineCollection ConstantLinesBehind { get { return (ConstantLineCollection)GetValue(ConstantLinesBehindProperty); } }
		[
#if !SL
	DevExpressXpfChartsLocalizedDescription("Axis2DConstantLinesInFront"),
#endif
		Category(Categories.Elements),
		XtraSerializableProperty(XtraSerializationVisibility.Collection, true, false, true)
		]
		public ConstantLineCollection ConstantLinesInFront { get { return (ConstantLineCollection)GetValue(ConstantLinesInFrontProperty); } }
		[
#if !SL
	DevExpressXpfChartsLocalizedDescription("Axis2DStrips"),
#endif
		Category(Categories.Elements),
		XtraSerializableProperty(XtraSerializationVisibility.Collection, true, false, true)
		]
		public StripCollection Strips { get { return (StripCollection)GetValue(StripsProperty); } }
		[
#if !SL
	DevExpressXpfChartsLocalizedDescription("Axis2DCustomLabels"),
#endif
		Category(Categories.Elements),
		XtraSerializableProperty(XtraSerializationVisibility.Collection, true, false, true)
		]
		public CustomAxisLabelCollection CustomLabels { get { return (CustomAxisLabelCollection)GetValue(CustomLabelsProperty); } }
		[
#if !SL
	DevExpressXpfChartsLocalizedDescription("Axis2DVisibilityInPanes"),
#endif
		Category(Categories.Behavior),
		XtraSerializableProperty(XtraSerializationVisibility.Collection, true, false, true)
		]
		public VisibilityInPaneCollection VisibilityInPanes { get { return (VisibilityInPaneCollection)GetValue(VisibilityInPanesProperty); } }
		[
#if !SL
	DevExpressXpfChartsLocalizedDescription("Axis2DVisible"),
#endif
		Category(Categories.Behavior),
		XtraSerializableProperty
		]
		public bool? Visible {
			get { return (bool?)GetValue(VisibleProperty); }
			set { SetValue(VisibleProperty, value); }
		}
		[
#if !SL
	DevExpressXpfChartsLocalizedDescription("Axis2DAlignment"),
#endif
		Category(Categories.Layout),
		XtraSerializableProperty
		]
		public AxisAlignment Alignment {
			get { return (AxisAlignment)GetValue(AlignmentProperty); }
			set { SetValue(AlignmentProperty, value); }
		}
		[
#if !SL
	DevExpressXpfChartsLocalizedDescription("Axis2DReverse"),
#endif
		Category(Categories.Behavior),
		XtraSerializableProperty
		]
		public bool Reverse {
			get { return (bool)GetValue(ReverseProperty); }
			set { SetValue(ReverseProperty, value); }
		}
		[
#if !SL
	DevExpressXpfChartsLocalizedDescription("Axis2DScrollingRange"),
#endif
		Category(Categories.Common),
		XtraSerializableProperty(XtraSerializationVisibility.Hidden, true),
		Obsolete(ObsoleteMessages.ScrollingRangeProperty),
		EditorBrowsable(EditorBrowsableState.Never),
		Browsable(false),
		]
		public AxisRange ScrollingRange {
			get { return (AxisRange)GetValue(ScrollingRangeProperty); }
			set { SetValue(ScrollingRangeProperty, value); }
		}
		[
		Category(Categories.Common),
		XtraSerializableProperty(XtraSerializationVisibility.Content, true)
		]
		public Range VisualRange {
			get { return (Range)GetValue(VisualRangeProperty); }
			set { SetValue(VisualRangeProperty, value); }
		}
		[
#if !SL
	DevExpressXpfChartsLocalizedDescription("Axis2DThickness"),
#endif
		Category(Categories.Presentation),
		XtraSerializableProperty
		]
		public int Thickness {
			get { return (int)GetValue(ThicknessProperty); }
			set { SetValue(ThicknessProperty, value); }
		}
		[
#if !SL
	DevExpressXpfChartsLocalizedDescription("Axis2DBrush"),
#endif
		Category(Categories.Brushes),
		XtraSerializableProperty
		]
		public Brush Brush {
			get { return (Brush)GetValue(BrushProperty); }
			set { SetValue(BrushProperty, value); }
		}
		[
#if !SL
	DevExpressXpfChartsLocalizedDescription("Axis2DTickmarksVisible"),
#endif
		Category(Categories.Behavior),
		XtraSerializableProperty
		]
		public bool TickmarksVisible {
			get { return (bool)GetValue(TickmarksVisibleProperty); }
			set { SetValue(TickmarksVisibleProperty, value); }
		}
		[
#if !SL
	DevExpressXpfChartsLocalizedDescription("Axis2DTickmarksMinorVisible"),
#endif
		Category(Categories.Behavior),
		XtraSerializableProperty
		]
		public bool TickmarksMinorVisible {
			get { return (bool)GetValue(TickmarksMinorVisibleProperty); }
			set { SetValue(TickmarksMinorVisibleProperty, value); }
		}
		[
#if !SL
	DevExpressXpfChartsLocalizedDescription("Axis2DTickmarksThickness"),
#endif
		Category(Categories.Presentation),
		XtraSerializableProperty
		]
		public int TickmarksThickness {
			get { return (int)GetValue(TickmarksThicknessProperty); }
			set { SetValue(TickmarksThicknessProperty, value); }
		}
		[
#if !SL
	DevExpressXpfChartsLocalizedDescription("Axis2DTickmarksMinorThickness"),
#endif
		Category(Categories.Presentation),
		XtraSerializableProperty
		]
		public int TickmarksMinorThickness {
			get { return (int)GetValue(TickmarksMinorThicknessProperty); }
			set { SetValue(TickmarksMinorThicknessProperty, value); }
		}
		[
#if !SL
	DevExpressXpfChartsLocalizedDescription("Axis2DTickmarksLength"),
#endif
		Category(Categories.Presentation),
		XtraSerializableProperty
		]
		public int TickmarksLength {
			get { return (int)GetValue(TickmarksLengthProperty); }
			set { SetValue(TickmarksLengthProperty, value); }
		}
		[
#if !SL
	DevExpressXpfChartsLocalizedDescription("Axis2DTickmarksMinorLength"),
#endif
		Category(Categories.Presentation),
		XtraSerializableProperty
		]
		public int TickmarksMinorLength {
			get { return (int)GetValue(TickmarksMinorLengthProperty); }
			set { SetValue(TickmarksMinorLengthProperty, value); }
		}
		[
#if !SL
	DevExpressXpfChartsLocalizedDescription("Axis2DTickmarksCrossAxis"),
#endif
		Category(Categories.Presentation),
		XtraSerializableProperty
		]
		public bool TickmarksCrossAxis {
			get { return (bool)GetValue(TickmarksCrossAxisProperty); }
			set { SetValue(TickmarksCrossAxisProperty, value); }
		}
		[Obsolete(ObsoleteMessages.Axis2DCrosshairLabelPatternProperty), Browsable(false), EditorBrowsable(EditorBrowsableState.Never), NonTestableProperty]
		public string CrosshairLabelPattern {
			get { return (string)GetValue(CrosshairLabelPatternProperty); }
			set { SetValue(CrosshairLabelPatternProperty, value); }
		}
		[Obsolete(ObsoleteMessages.Axis2DCrosshairLabelVisibilityProperty), Browsable(false), EditorBrowsable(EditorBrowsableState.Never), NonTestableProperty]
		public bool? CrosshairLabelVisibility {
			get { return (bool?)GetValue(CrosshairLabelVisibilityProperty); }
			set { SetValue(CrosshairLabelVisibilityProperty, value); }
		}
		[
#if !SL
	DevExpressXpfChartsLocalizedDescription("Axis2DCrosshairLabelTemplate"),
#endif
		Category(Categories.Appearance)
		]
		public DataTemplate CrosshairLabelTemplate {
			get { return (DataTemplate)GetValue(CrosshairLabelTemplateProperty); }
			set { SetValue(CrosshairLabelTemplateProperty, value); }
		}
		[
#if !SL
	DevExpressXpfChartsLocalizedDescription("Axis2DCrosshairAxisLabelOptions"),
#endif
		Category(Categories.Appearance),
		XtraSerializableProperty(XtraSerializationVisibility.Content, true)
		]
		public CrosshairAxisLabelOptions CrosshairAxisLabelOptions {
			get { return (CrosshairAxisLabelOptions)GetValue(CrosshairAxisLabelOptionsProperty); }
			set { SetValue(CrosshairAxisLabelOptionsProperty, value); }
		}
		[
#if !SL
	DevExpressXpfChartsLocalizedDescription("Axis2DLabelVisibilityMode"),
#endif
		Category(Categories.Elements),
		XtraSerializableProperty
		]
		public AxisLabelVisibilityMode LabelVisibilityMode {
			get { return (AxisLabelVisibilityMode)GetValue(LabelVisibilityModeProperty); }
			set { SetValue(LabelVisibilityModeProperty, value); }
		}
		CrosshairAxisLabelOptions defaultCrosshairAxisLabelOptions;
		bool reverse = false;
		internal AxisLabelResolveOverlappingCache OverlappingCache { get; set; }
		internal XYDiagram2D Diagram2D { get { return ((IChartElement)this).Owner as XYDiagram2D; } }
		internal bool ActualVisible {
			get {
				if (Visible.HasValue)
					return Visible.Value;
				return autoLayoutVisible;
			}
		}
		internal AxisPosition Position {
			get {
				switch (Alignment) {
					case AxisAlignment.Near:
						return IsVertical ? AxisPosition.Left : AxisPosition.Bottom;
					case AxisAlignment.Far:
						return IsVertical ? AxisPosition.Right : AxisPosition.Top;
					default:
						ChartDebug.Fail("Unknown axis alignment.");
						goto case AxisAlignment.Near;
				}
			}
		}
		internal CrosshairAxisLabelOptions ActualCrosshairAxisLabelOptions {
			get {
				if (defaultCrosshairAxisLabelOptions == null) {
					defaultCrosshairAxisLabelOptions = new CrosshairAxisLabelOptions();
					defaultCrosshairAxisLabelOptions.Owner = this;
				}
				return CrosshairAxisLabelOptions == null ? defaultCrosshairAxisLabelOptions : CrosshairAxisLabelOptions;
			}
		}
		internal Brush ActualCrosshairLineBrush {
			get {
				if (Diagram2D != null && Diagram2D.ChartControl != null)
					return IsValuesAxis ? Diagram2D.ChartControl.ActualCrosshairOptions.ActualValueLineBrush : Diagram2D.ChartControl.ActualCrosshairOptions.ActualArgumentLineBrush;
				else
					return null;
			}
		}
		internal Func<GRealSize2D, GRealSize2D> DecreaseSizeDelegate { private get; set; }
		internal Func<GRealRect2D> GetBoundsDelegate { private get; set; }
		internal void CompleteDeserializing() {
			foreach (VisibilityInPane visibility in VisibilityInPanes)
				visibility.CompleteDeserializing();
		}
		internal bool ReverseInternal { get { return reverse; } set { reverse = value; } }
		protected abstract int LayoutPriority { get; }
		protected override IEnumerable<IConstantLine> ConstantLinesImpl {
			get {
				List<IConstantLine> constantLines = new List<IConstantLine>();
				constantLines.AddRange(ConstantLinesBehind);
				constantLines.AddRange(ConstantLinesInFront);
				return constantLines;
			}
		}
		protected override IEnumerable<IStrip> StripsImpl { get { return Strips; } }
		protected override IEnumerable<ICustomAxisLabel> CustomLabelsImpl { get { return CustomLabels; } }
		protected override bool CanShowCustomWithAutoLabels { get { return LabelVisibilityMode == AxisLabelVisibilityMode.AutoGeneratedAndCustom; } }
		protected internal override AxisAlignment ActualAlignment { get { return Alignment; } }
		protected internal override bool IsReversed { get { return ReverseInternal; } }
		protected internal override bool ShouldRotateTitle { get { return IsVertical; } }
		protected internal override AxisVisibilityInPanes ActualVisibilityInPanes { get { return actualVisibilityInPanes; } }
		[Obsolete]
		static Axis2D() {
			ScrollingRangeProperty = DependencyPropertyManager.Register("ScrollingRange", typeof(AxisRange), typeof(Axis2D), new PropertyMetadata(ScrollingRangePropertyChanged));
		}
		public Axis2D() {
			BeginInit();
			actualVisibilityInPanes = new ActualAxisVisibilityInPanes(this);
#pragma warning disable 0612, 0618
			actualScrollingRange = new AxisRange();
			actualScrollingRange.ChangeOwner(null, this);
#pragma warning restore 0612, 0618
			actualVisualRange = new Range();
			actualVisualRange.ChangeOwner(null, this);
			actualVisualRange.SetRangeData(VisualRangeData);
			CreateMediator();
			this.SetValue(ConstantLinesBehindPropertyKey, ChartElementHelper.CreateInstance<ConstantLineCollection>(this));
			this.SetValue(ConstantLinesInFrontPropertyKey, ChartElementHelper.CreateInstance<ConstantLineCollection>(this));
			this.SetValue(StripsPropertyKey, ChartElementHelper.CreateInstance<StripCollection>(this));
			this.SetValue(CustomLabelsPropertyKey, ChartElementHelper.CreateInstance<CustomAxisLabelCollection>(ActualLabel));
			this.SetValue(VisibilityInPanesPropertyKey, ChartElementHelper.CreateInstance<VisibilityInPaneCollection>(this));
			EndInit();
		}
		#region ITransformable Members
		Transform ITransformable.GeometryTransform {
			get {
				switch (Position) {
					case AxisPosition.Left:
						return new ScaleTransform() { ScaleX = -1, ScaleY = -1 };
					case AxisPosition.Right:
					case AxisPosition.Top:
						return new ScaleTransform() { ScaleY = -1 };
					default:
						return new MatrixTransform() { Matrix = Matrix.Identity };
				}
			}
		}
		#endregion
		#region IResolveLabelsOverlappingAxis implementation
		AxisLabelResolveOverlappingCache IResolveLabelsOverlappingAxis.OverlappingCache {
			get { return OverlappingCache; }
			set { OverlappingCache = value; }
		}
		#endregion
		#region ISupportVisibilityControlElement Members
		int ISupportVisibilityControlElement.Priority {
			get { return LayoutPriority; }
		}
		bool ISupportVisibilityControlElement.Visible {
			get {
				if (!this.Visible.HasValue)
					return autoLayoutVisible;
				return this.Visible.Value;
			}
			set {
				if (!this.Visible.HasValue)
					autoLayoutVisible = value;
			}
		}
		bool autoLayoutVisible;
		GRealRect2D ISupportVisibilityControlElement.Bounds {
			get {
				if (GetBoundsDelegate == null)
					return new GRealRect2D();
				return GetBoundsDelegate();
			}
		}
		VisibilityElementOrientation ISupportVisibilityControlElement.Orientation {
			get {
				if (this.IsVertical)
					return VisibilityElementOrientation.Vertical;
				return VisibilityElementOrientation.Horizontal;
			}
		}		
		#endregion
		void FillConstantLinesLegendItems(IList<LegendItem> legendItems, IEnumerable<ConstantLine> constantLines) {
			foreach (ConstantLine constantLine in constantLines) {
				LegendItem item = constantLine.GetLegendItem();
				if (item != null)
					legendItems.Add(item);
			}
		}
		protected override GRealRect2D GetLabelBounds(Pane pane) {
			return pane.GetLabelBounds(this);
		}
		internal void FillConstantLinesLegendItems(IList<LegendItem> legendItems) {
			FillConstantLinesLegendItems(legendItems, ConstantLinesBehind);
			FillConstantLinesLegendItems(legendItems, ConstantLinesInFront);
		}
		internal void FillStripsLegendItems(IList<LegendItem> legendItems) {
			foreach (Strip strip in Strips) {
				string legendText = strip.LegendText;
				if (!String.IsNullOrEmpty(legendText) && strip.Visible)
					legendItems.Add(new LegendItem(strip, strip, legendText, strip.Brush));
			}
		}
		internal void RangeLimitsUpdated() {
			XYDiagram2D diagram = Diagram2D;
			if (diagram != null) {
				AxisPaneContainer axisPaneRepository = diagram.AxisPaneContainer;
				PaneAxesContainerRepository paneAxisRepository = diagram.PaneAxesContainerRepository;
				if (axisPaneRepository != null && paneAxisRepository != null) {
					IList<IPane> panes = axisPaneRepository.GetPanes(this);
					if (panes != null)
						foreach (Pane pane in panes) {
							PaneAxesContainer container = paneAxisRepository.GetContaiter(pane);
							if (container != null) {
								ScrollBarItem scrollBarItem;
								if (container.PrimaryAxisX == this)
									scrollBarItem = pane.AxisXScrollBarItem;
								else if (container.PrimaryAxisY == this)
									scrollBarItem = pane.AxisYScrollBarItem;
								else
									scrollBarItem = null;
								if (scrollBarItem != null) {
									IMinMaxValues visualRange = ((IAxisData)this).VisualRange;
									IMinMaxValues wholeRange = ((IAxisData)this).WholeRange;
									double min = wholeRange.Min;
									double delta = wholeRange.Delta;
									if (IsReversed) {
										scrollBarItem.MinPosition = 1 - (visualRange.Max - min) / delta;
										scrollBarItem.MaxPosition = 1 - (visualRange.Min - min) / delta;
									}
									else {
										scrollBarItem.MinPosition = (visualRange.Min - min) / delta;
										scrollBarItem.MaxPosition = (visualRange.Max - min) / delta;
									}
								}
							}
						}
				}
			}
		}
		internal double CalcInternalValue(Pane pane, double coordinate, double length) {
			IAxisMapping axisMapping = CreateMapping(pane.Viewport);
			return axisMapping.GetInternalCoord(coordinate, length);
		}
		internal double CalcAxisValue(Pane pane, double valueInternal) {
			IAxisMapping axisMapping = CreateMapping(pane.Viewport);
			return axisMapping.GetAxisValue(valueInternal);
		}
		internal bool IsValueInRange(double value) {
			IMinMaxValues limits = ((IAxisData)this).VisualRange;
			return value >= limits.Min && value <= limits.Max;
		}
		protected internal override IAxisMapping CreateMapping(Rect bounds) {
			return new AxisMappingEx(this, IsVertical ? bounds.Height : bounds.Width);
		}
		protected override void LabelPropertyChanged() {
			((IOwnedElement)CustomLabels).Owner = ActualLabel;
		}
		protected override void ScaleTypeUpdated() {
			base.ScaleTypeUpdated();
#pragma warning disable 0612
			if (actualScrollingRange != null)
				actualScrollingRange.UpdateMinMaxValues(this);
#pragma warning restore 0612
			foreach (Strip strip in Strips)
				strip.UpdateMinMaxLimits();
		}
		protected internal override GridLineGeometry CreateGridLineGeometry(Rect axisBounds, IAxisMapping mapping, double axisValue, int thickness) {
			double position = Render2DHelper.CorrectLinePosition(mapping.GetRoundedClampedAxisValue(axisValue), thickness);
			Point p1, p2;
			if (IsVertical) {
				p1 = new Point(0, axisBounds.Height - position);
				p2 = new Point(axisBounds.Width, axisBounds.Height - position);
			}
			else {
				p1 = new Point(position, 0);
				p2 = new Point(position, axisBounds.Height);
			}
			return new GridLineGeometry(GridLineType.Polyline, new List<Point>() { p1, p2 });
		}
		protected internal override InterlaceGeometry CreateInterlaceGeometry(Rect axisBounds, IAxisMapping mapping, double nearAxisValue, double farAxisValue) {
			double near = mapping.GetRoundedClampedAxisValue(nearAxisValue);
			double far = mapping.GetRoundedClampedAxisValue(farAxisValue);
			Point p1, p2;
			if (IsVertical) {
				near = axisBounds.Height - near;
				far = axisBounds.Height - far;
				Render2DHelper.CorrectBounds(ref near, ref far);
				p1 = new Point(0, Math.Min(near, far));
				p2 = new Point(axisBounds.Width, Math.Max(near, far));
			}
			else {
				Render2DHelper.CorrectBounds(ref near, ref far);
				p1 = new Point(Math.Min(near, far), 0);
				p2 = new Point(Math.Max(near, far), axisBounds.Height);
			}
			return new InterlaceGeometry(InterlaceType.Rectangle, new List<Point>() { p1, p2 }, new List<Point>(), new Rect(p1, p2));
		}
		protected internal override void CreateMediator() {
			Range.MediatorResolver mediator = new Range.MediatorResolver(ActualVisualRange, ActualWholeRange);
		}
		internal void UpdateVisibilityInPanes() {
			actualVisibilityInPanes.UpdateVisibilityInPanes(VisibilityInPanes);
		}
		protected internal override void UpdateUserValues() {
			base.UpdateUserValues();
#pragma warning disable 0612
			DeserializeObsolete();
#pragma warning restore 0612
			if (ActualVisualRange != null)
				ActualVisualRange.UpdateMinMaxValues(this);
		}
		[Obsolete]
		void DeserializeObsolete() {
			if (ScrollingRange != null)
				ScrollingRange.UpdateMinMaxValues(this);
		}
		public bool ShouldSerializeVisible(XamlDesignerSerializationManager manager) {
			return this.Visible.HasValue;
		}
	}
	public class AxisX2D : Axis2D {
		public static readonly DependencyProperty DateTimeScaleOptionsProperty = DependencyPropertyManager.Register("DateTimeScaleOptions",
			typeof(DateTimeScaleOptionsBase), typeof(AxisX2D), new PropertyMetadata(DateTimeScaleOptionsPropertyChanged));
		public static readonly DependencyProperty NumericScaleOptionsProperty = DependencyPropertyManager.Register("NumericScaleOptions",
			typeof(NumericScaleOptionsBase), typeof(AxisX2D), new PropertyMetadata(NumericScaleOptionsPropertyChanged));
		[
#if !SL
	DevExpressXpfChartsLocalizedDescription("AxisX2DDateTimeScaleOptions"),
#endif
		Category(Categories.Behavior),
		XtraSerializableProperty(XtraSerializationVisibility.Content, true)
		]
		public DateTimeScaleOptionsBase DateTimeScaleOptions {
			get { return (DateTimeScaleOptionsBase)GetValue(DateTimeScaleOptionsProperty); }
			set { SetValue(DateTimeScaleOptionsProperty, value); }
		}
		[
#if !SL
	DevExpressXpfChartsLocalizedDescription("AxisX2DNumericScaleOptions"),
#endif
		Category(Categories.Behavior),
		XtraSerializableProperty(XtraSerializationVisibility.Content, true)
		]
		public NumericScaleOptionsBase NumericScaleOptions {
			get { return (NumericScaleOptionsBase)GetValue(NumericScaleOptionsProperty); }
			set { SetValue(NumericScaleOptionsProperty, value); }
		}
		readonly ManualDateTimeScaleOptions defaultDateTimeScaleOptions = new ManualDateTimeScaleOptions();
		readonly ContinuousNumericScaleOptions defaultNumericScaleOptions = new ContinuousNumericScaleOptions();
		protected override DateTimeScaleOptionsBase DefaultDateTimeScaleOptions { get { return defaultDateTimeScaleOptions; } }
		protected override NumericScaleOptionsBase DefaultNumericScaleOptions { get { return defaultNumericScaleOptions; } }
		protected override int LayoutPriority { get { return (int)ChartElementVisibilityPriority.AxisX; } }
		protected override int GridSpacingFactor { get { return 100; } }
		protected internal override bool IsValuesAxis { get { return false; } }
		protected internal override bool IsVertical {
			get {
				XYDiagram2D diagram = Diagram2D as XYDiagram2D;
				return diagram != null && diagram.Rotated;
			}
		}
		[Obsolete]
		protected override AxisRange ScrollingRangeValue { get { return Diagram2D != null && Diagram2D.IsNavigationAxisXEnabled ? ActualScrollingRange : ActualRange; } }
		public AxisX2D() {
			DefaultStyleKey = typeof(AxisX2D);
		}
	}
	public class AxisY2D : Axis2D {
		public static readonly DependencyProperty DateTimeScaleOptionsProperty = DependencyPropertyManager.Register("DateTimeScaleOptions",
			typeof(ContinuousDateTimeScaleOptions), typeof(AxisY2D), new PropertyMetadata(DateTimeScaleOptionsPropertyChanged));
		public static readonly DependencyProperty NumericScaleOptionsProperty = DependencyPropertyManager.Register("NumericScaleOptions",
			typeof(ContinuousNumericScaleOptions), typeof(AxisY2D), new PropertyMetadata(NumericScaleOptionsPropertyChanged));
		[
#if !SL
	DevExpressXpfChartsLocalizedDescription("AxisY2DDateTimeScaleOptions"),
#endif
		Category(Categories.Behavior),
		XtraSerializableProperty(XtraSerializationVisibility.Content, true)
		]
		public ContinuousDateTimeScaleOptions DateTimeScaleOptions {
			get { return (ContinuousDateTimeScaleOptions)GetValue(DateTimeScaleOptionsProperty); }
			set { SetValue(DateTimeScaleOptionsProperty, value); }
		}
		[
#if !SL
	DevExpressXpfChartsLocalizedDescription("AxisY2DNumericScaleOptions"),
#endif
		Category(Categories.Behavior),
		XtraSerializableProperty(XtraSerializationVisibility.Content, true)
		]
		public ContinuousNumericScaleOptions NumericScaleOptions {
			get { return (ContinuousNumericScaleOptions)GetValue(NumericScaleOptionsProperty); }
			set { SetValue(NumericScaleOptionsProperty, value); }
		}
		public static readonly DependencyProperty AlwaysShowZeroLevelProperty = DependencyPropertyManager.RegisterAttached("AlwaysShowZeroLevel",
			typeof(bool), typeof(AxisY2D), new PropertyMetadata(true, AlwaysShowZeroLevelPropertyChanged));
		[
		Category(Categories.Behavior),
		XtraSerializableProperty
		]
		public static bool GetAlwaysShowZeroLevel(ChartNonVisualElement range) {
			return (bool)range.GetValue(AlwaysShowZeroLevelProperty);
		}
		public static void SetAlwaysShowZeroLevel(ChartNonVisualElement range, bool value) {
			range.SetValue(AlwaysShowZeroLevelProperty, value);
		}
		internal static void AlwaysShowZeroLevelPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e) {
#pragma warning disable 0612
			AxisRangeAlwaysShowZeroLevelPropertyChanged(d, e);
#pragma warning restore 0612
			Range range = d as Range;
			if (range != null)
				DevExpress.Xpf.Charts.Range.AlwaysShowZeroLevelPropertyChanged(d, e);
		}
		[Obsolete]
		internal static void AxisRangeAlwaysShowZeroLevelPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e) {
			AxisRange axisRange = d as AxisRange;
			if (axisRange != null)
				AxisRange.AlwaysShowZeroLevelPropertyChanged(d, e);
		}
		readonly ContinuousDateTimeScaleOptions defaultDateTimeScaleOptionsImpl = new ContinuousDateTimeScaleOptions();
		readonly ContinuousNumericScaleOptions defaultNumericScaleOptionsImpl = new ContinuousNumericScaleOptions();
		protected override DateTimeScaleOptionsBase DefaultDateTimeScaleOptions { get { return defaultDateTimeScaleOptionsImpl; } }
		protected override NumericScaleOptionsBase DefaultNumericScaleOptions { get { return defaultNumericScaleOptionsImpl; } }
		protected override int LayoutPriority { get { return (int)ChartElementVisibilityPriority.AxisY; } }
		protected override int GridSpacingFactor { get { return 70; } }
		protected internal override bool IsValuesAxis { get { return true; } }
		protected internal override bool IsVertical {
			get {
				XYDiagram2D diagram = Diagram2D as XYDiagram2D;
				return diagram == null || !diagram.Rotated;
			}
		}
		[Obsolete]
		protected override AxisRange ScrollingRangeValue { get { return Diagram2D != null && Diagram2D.IsNavigationAxisYEnabled ? ActualScrollingRange : ActualRange; } }
		public AxisY2D() {
			DefaultStyleKey = typeof(AxisY2D);
		}
		protected internal override bool GetActualAlwaysShowZeroLevel(ChartNonVisualElement range) {
			return GetAlwaysShowZeroLevel(range);
		}
	}
}
