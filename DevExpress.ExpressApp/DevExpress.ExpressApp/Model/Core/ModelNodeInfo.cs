#region Copyright (c) 2000-2015 Developer Express Inc.
/*
{*******************************************************************}
{                                                                   }
{       Developer Express .NET Component Library                    }
{       eXpressApp Framework                                        }
{                                                                   }
{       Copyright (c) 2000-2015 Developer Express Inc.              }
{       ALL RIGHTS RESERVED                                         }
{                                                                   }
{   The entire contents of this file is protected by U.S. and       }
{   International Copyright Laws. Unauthorized reproduction,        }
{   reverse-engineering, and distribution of all or any portion of  }
{   the code contained in this file is strictly prohibited and may  }
{   result in severe civil and criminal penalties and will be       }
{   prosecuted to the maximum extent possible under the law.        }
{                                                                   }
{   RESTRICTIONS                                                    }
{                                                                   }
{   THIS SOURCE CODE AND ALL RESULTING INTERMEDIATE FILES           }
{   ARE CONFIDENTIAL AND PROPRIETARY TRADE                          }
{   SECRETS OF DEVELOPER EXPRESS INC. THE REGISTERED DEVELOPER IS   }
{   LICENSED TO DISTRIBUTE THE PRODUCT AND ALL ACCOMPANYING .NET    }
{   CONTROLS AS PART OF AN EXECUTABLE PROGRAM ONLY.                 }
{                                                                   }
{   THE SOURCE CODE CONTAINED WITHIN THIS FILE AND ALL RELATED      }
{   FILES OR ANY PORTION OF ITS CONTENTS SHALL AT NO TIME BE        }
{   COPIED, TRANSFERRED, SOLD, DISTRIBUTED, OR OTHERWISE MADE       }
{   AVAILABLE TO OTHER INDIVIDUALS WITHOUT EXPRESS WRITTEN CONSENT  }
{   AND PERMISSION FROM DEVELOPER EXPRESS INC.                      }
{                                                                   }
{   CONSULT THE END USER LICENSE AGREEMENT FOR INFORMATION ON       }
{   ADDITIONAL RESTRICTIONS.                                        }
{                                                                   }
{*******************************************************************}
*/
#endregion Copyright (c) 2000-2015 Developer Express Inc.

using System;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using DevExpress.ExpressApp.DC;
using DevExpress.ExpressApp.Utils;
namespace DevExpress.ExpressApp.Model.Core {
	public sealed class ModelNodeInfo {
		const int MaximumDefaultValueFunctionCallCounter = 100;
		static readonly Dictionary<string, Type> EmptyStringTypeDictionary = new Dictionary<string, Type>();
		sealed class XmlNameRect {
			readonly string name;
			readonly string xmlName;
			internal XmlNameRect(string name, string xmlName) {
				Guard.ArgumentNotNullOrEmpty(name, "name");
				Guard.ArgumentNotNullOrEmpty(xmlName, "xmlName");
				this.name = name;
				this.xmlName = xmlName;
			}
			internal string Name { get { return name; } }
			internal string XmlName { get { return xmlName; } }
		}
		sealed class NameTypeRect {
			readonly string name;
			readonly Type type;
			readonly Type ownerType;
			readonly bool isList;
			readonly bool isAutoGenerated;
			internal NameTypeRect(string name, Type type, Type ownerType, bool isList, bool isAutoGenerated) {
				Guard.ArgumentNotNullOrEmpty(name, "name");
				Guard.ArgumentNotNull(type, "type");
				this.name = name;
				this.type = type;
				this.ownerType = ownerType;
				this.isList = isList;
				this.isAutoGenerated = isAutoGenerated && !isList;
			}
			internal string Name { get { return name; } }
			internal Type Type { get { return type; } }
			internal Type OwnerType { get { return ownerType; } }
			internal bool IsList { get { return isList; } }
			internal bool IsAutoGenerated { get { return isAutoGenerated; } }
		}
		sealed class DefaultValueItem {
			readonly IModelValueCalculator iCalculator;
			readonly ModelValueDefaultCalculator mCalculator;
			readonly object value;
			readonly string sourceNodePath;
			internal DefaultValueItem(IModelValueCalculator iCalculator, ModelValueDefaultCalculator mCalculator, object value, string sourceNodePath) {
				this.iCalculator = iCalculator;
				this.mCalculator = mCalculator;
				this.value = value;
				this.sourceNodePath = sourceNodePath;
			}
			internal object Value { get { return value; } }
			internal string SourceNodePath { get { return sourceNodePath; } }
			internal ModelValuePersistentPathCalculator PathCalculator { get { return iCalculator as ModelValuePersistentPathCalculator; } }
			internal object CalcValue(ModelNode node, string propertyName) {
				Guard.ArgumentNotNull(node, "node");
				Guard.ArgumentNotNullOrEmpty(propertyName, "propertyName");
				if(iCalculator != null) {
					return iCalculator.Calculate(node, propertyName);
				}
				if(mCalculator != null) {
					return mCalculator(node);
				}
				return value;
			}
		}
		readonly ModelApplicationCreator applicationCreator;
		readonly ModelNodeCreatorMethod nodeCreator;
		readonly Type generatedClass;
		readonly Type baseInterface;
		readonly ModelNodesGeneratorBase nodesGenerator;
		readonly string keyProperty;
		Dictionary<string, DefaultValueItem> defaultValues;
		Dictionary<string, ModelValueInfo> valuesInfo;
		List<NameTypeRect> childrenInfo;
		List<XmlNameRect> xmlNames;
		List<IModelNodeValidator> validators;
		List<IModelNodeUpdater> updaters;
		Dictionary<string, Type> listChildrenTypes;
		Dictionary<string, Type> propertyChildrenTypes;
		Dictionary<string, Type> allChildrenTypes;
		Comparison<ModelNode> childNodesComparison;
		int defaultValueFunctionCallCounter;
		internal ModelNodeInfo(ModelApplicationCreator applicationCreator, ModelNodeCreatorMethod nodeCreator, Type generatedClass, Type baseInterface, ModelNodesGeneratorBase nodesGenerator, string keyProperty) {
			Guard.ArgumentNotNull(applicationCreator, "applicationCreator");
			Guard.ArgumentNotNull(generatedClass, "generatedClass");
			Guard.ArgumentNotNull(baseInterface, "baseInterface");
			Guard.ArgumentNotNull(nodesGenerator, "nodesGenerator");
			this.applicationCreator = applicationCreator;
			this.nodeCreator = nodeCreator;
			this.generatedClass = generatedClass;
			this.baseInterface = baseInterface;
			this.nodesGenerator = nodesGenerator;
			this.keyProperty = keyProperty;
			CreateValuesInfo();
		}
		public ModelApplicationCreator ApplicationCreator { get { return applicationCreator; } }
		public Type GeneratedClass { get { return generatedClass; } }
		public Type BaseInterface { get { return baseInterface; } }
		[Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
		public ModelNodesGeneratorBase NodesGenerator { get { return nodesGenerator; } }
		public string KeyProperty { get { return keyProperty; } }
		[Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
		public string KeyName { get { return string.IsNullOrEmpty(KeyProperty) ? ModelValueNames.Id : KeyProperty; } }
		[Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
		public bool IsKeyPropertyName(string name) {
			return name == ModelValueNames.Id || name == KeyProperty;
		}
		[Browsable(false), EditorBrowsable(EditorBrowsableState.Never), DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Hidden)]
		public Comparison<ModelNode> ChildNodesComparison {
			get {
				if(childNodesComparison != null) {
					return childNodesComparison;
				}
				return SortChildNodesHelper.DoSortNodesByDefault;
			}
			set { childNodesComparison = value; }
		}
		Dictionary<string, DefaultValueItem> DefaultValues { get { return defaultValues; } }
		List<NameTypeRect> ChildrenInfo { get { return childrenInfo; } }
		List<XmlNameRect> XmlNames { get { return xmlNames; } }
		private void CreateValuesInfo() {
			valuesInfo = new Dictionary<string, ModelValueInfo>();
			valuesInfo[ModelValueNames.Id] = ModelValueInfo.IdValueInfo;
			valuesInfo[ModelValueNames.Index] = ModelValueInfo.IndexValueInfo;
			valuesInfo[ModelValueNames.IsNewNode] = ModelValueInfo.IsNewNodeValueInfo;
			valuesInfo[ModelValueNames.IsRemovedNode] = ModelValueInfo.IsRemovedNodeValueInfo;
		}
		[Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
		public ModelNode CreateNode(string nodeId) {
			return nodeCreator(this, nodeId);
		}
		public ModelValueInfo GetValueInfo(string propertyName) {
			Guard.ArgumentNotNullOrEmpty(propertyName, "propertyName");
			ModelValueInfo result;
			valuesInfo.TryGetValue(propertyName, out result);
			return result;
		}
		[Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
		public ModelValuePersistentPathCalculator GetPathCalculator(string propertyName) {
			Guard.ArgumentNotNullOrEmpty(propertyName, "propertyName");
			if(DefaultValues != null) {
				DefaultValueItem item;
				if(DefaultValues.TryGetValue(propertyName, out item)) {
					ModelValuePersistentPathCalculator pathCalculator = item.PathCalculator;
					if(pathCalculator != null) {
						ModelValueInfo valueInfo = GetValueInfo(propertyName);
						if(valueInfo != null && valueInfo.CanPersistentPathBeUsed) {
							return pathCalculator;
						}
					}
				}
			}
			return null;
		}
		internal bool IsDefaultValueCalculationInProgress { get { return defaultValueFunctionCallCounter > 0; } }
		[Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
		public object GetDefaultValue(ModelNode node, string propertyName) {
			Guard.ArgumentNotNullOrEmpty(propertyName, "propertyName");
			if(DefaultValues != null) {
				DefaultValueItem item;
				if(DefaultValues.TryGetValue(propertyName, out item)) {
					if(defaultValueFunctionCallCounter > MaximumDefaultValueFunctionCallCounter) {
						defaultValueFunctionCallCounter = 0;
						throw new Exception(string.Format("There is the call stack error in custom logic for {0}.{1}", BaseInterface.Name, propertyName));
					}
					defaultValueFunctionCallCounter++;
					object result = item.CalcValue(node, propertyName);
					defaultValueFunctionCallCounter--;
					return result;
				}
			}
			return null;
		}
		[Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
		public string GetSourceNodePath(string propertyName) {
			Guard.ArgumentNotNullOrEmpty(propertyName, "propertyName");
			if(DefaultValues != null) {
				DefaultValueItem item;
				if(DefaultValues.TryGetValue(propertyName, out item)) {
					return item.SourceNodePath;
				}
			}
			return null;
		}
		[Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
		public bool IsCalculated(string propertyName) {
			Guard.ArgumentNotNullOrEmpty(propertyName, "propertyName");
			if(DefaultValues != null && !string.IsNullOrEmpty(propertyName)) {
				DefaultValueItem item;
				if(DefaultValues.TryGetValue(propertyName, out item)) {
					return item.Value == null;
				}
			}
			return false;
		}
		[Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
		public void AddValueInfo(string name, Type propertyType, bool isLocalizable, bool isReadOnly, string persistentPath, string converterTypeName) {
			Guard.ArgumentNotNullOrEmpty(name, "name");
			Guard.ArgumentNotNull(propertyType, "propertyType");
			this.valuesInfo[name] = new ModelValueInfo(name, propertyType, isLocalizable, isReadOnly, persistentPath, converterTypeName);
		}
		[Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
		public void AddListChildInfo(string childName, Type type, Type ownerType) {
			Guard.ArgumentNotNullOrEmpty(childName, "childName");
			Guard.ArgumentNotNull(type, "type");
			AddChildInfo(childName, type, ownerType, true, false);
		}
		[Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
		public void AddChildInfo(string childName, Type type, Type ownerType, bool isAutoGenerated) {
			Guard.ArgumentNotNullOrEmpty(childName, "childName");
			Guard.ArgumentNotNull(type, "type");
			AddChildInfo(childName, type, ownerType, false, isAutoGenerated);
		}
		private void AddChildInfo(string childName, Type type, Type ownerType, bool isList, bool isAutoGenerated) {
			if(ChildrenInfo == null) {
				childrenInfo = new List<NameTypeRect>();
			}
			ChildrenInfo.Add(new NameTypeRect(childName, type, ownerType, isList, isAutoGenerated));
		}
		[Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
		public void AddXmlName(string name, string xmlName) {
			Guard.ArgumentNotNullOrEmpty(name, "name");
			Guard.ArgumentNotNullOrEmpty(xmlName, "xmlName");
			if(XmlNames == null) {
				this.xmlNames = new List<XmlNameRect>();
			}
			XmlNames.Add(new XmlNameRect(name, xmlName));
		}
		[Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
		public void AddDefaultValue(string propertyName, IModelValueCalculator iCalculator) {
			Guard.ArgumentNotNullOrEmpty(propertyName, "propertyName");
			Guard.ArgumentNotNull(iCalculator, "iCalculator");
			AddDefaultValue(propertyName, iCalculator, null, null, null);
		}
		[Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
		public void AddDefaultValue(string propertyName, ModelValueDefaultCalculator mCalculator, string sourceNodePath) {
			Guard.ArgumentNotNullOrEmpty(propertyName, "propertyName");
			Guard.ArgumentNotNull(mCalculator, "mCalculator");
			AddDefaultValue(propertyName, null, mCalculator, null, sourceNodePath);
		}
		[Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
		public void AddDefaultValue(string propertyName, object defaultValue) {
			Guard.ArgumentNotNullOrEmpty(propertyName, "propertyName");
			Guard.ArgumentNotNull(defaultValue, "defaultValue");
			AddDefaultValue(propertyName, null, null, defaultValue, null);
		}
		private void AddDefaultValue(string propertyName, IModelValueCalculator iCalculator, ModelValueDefaultCalculator mCalculator, object value, string sourceNodePath) {
			if(DefaultValues == null) {
				defaultValues = new Dictionary<string, DefaultValueItem>();
			}
			DefaultValues[propertyName] = new DefaultValueItem(iCalculator, mCalculator, value, sourceNodePath);
		}
		[Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
		public string GetXmlNameByChildNodeType(Type childNodeType) {
			Guard.ArgumentNotNull(childNodeType, "childNodeType");
			return GetNameByChildNodeType(childNodeType, true);
		}
		[Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
		public string GetNameByChildNodeType(Type childNodeType) {
			Guard.ArgumentNotNull(childNodeType, "childNodeType");
			if(CanGetNameByChildNodeType(childNodeType)) {
				return GetNameByChildNodeType(childNodeType, false);
			}
			return null;
		}
		[Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
		public Type GetTypeByChildNodeXmlName(string childNodeName) {
			Guard.ArgumentNotNullOrEmpty(childNodeName, "childNodeName");
			return GetTypeByChildNodeName(childNodeName, true);
		}
		[Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
		public Type GetTypeByChildNodeName(string childNodeName) {
			Guard.ArgumentNotNullOrEmpty(childNodeName, "childNodeName");
			return GetTypeByChildNodeName(childNodeName, false);
		}
		[Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
		public bool IsRequireWriteId(Type childNodeType) {
			Guard.ArgumentNotNull(childNodeType, "childNodeType");
			if(ChildrenInfo != null) {
				bool result = true;
				foreach(NameTypeRect rect in ChildrenInfo) {
					if(childNodeType == rect.Type) {
						if(rect.IsList) {
							return true;
						}
						result = false;
					}
				}
				return result;
			}
			return true;
		}
		bool CanGetNameByChildNodeType(Type childNodeType) {
			if(ChildrenInfo != null) {
				int counter = 0;
				foreach(NameTypeRect rect in ChildrenInfo) {
					if(childNodeType == rect.Type && !rect.IsList) {
						counter++;
					}
				}
				return counter == 1;
			}
			return false;
		}
		public IEnumerable<ModelValueInfo> ValuesInfo { get { return valuesInfo.Values; } }
		[Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
		public Dictionary<string, Type> GetListChildrenTypes() {
			return GetChildrenTypes(ChildrenType.ListOnly);
		}
		[Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
		public Dictionary<string, Type> GetPropertyChildrenTypes() {
			return GetChildrenTypes(ChildrenType.PropertyOnly);
		}
		[Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
		public Dictionary<string, Type> GetChildrenTypes() {
			return GetChildrenTypes(ChildrenType.All);
		}
		[Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
		public void GenerateNodesByDefault(ModelNode parent) {
			Guard.ArgumentNotNull(parent, "parent");
			if(ChildrenInfo != null) {
				foreach(NameTypeRect rec in ChildrenInfo) {
					if(rec.IsAutoGenerated && parent.GetNode(rec.Name) == null) {
						parent.AddNode(rec.Name, rec.Type);
					}
				}
			}
		}
		[Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
		public bool CanCreateListChildNode(Type type) {
			Guard.ArgumentNotNull(type, "type");
			Dictionary<string, Type> listTypes = GetListChildrenTypes();
			if(listTypes.Count == 0) {
				return true;
			}
			foreach(Type childType in listTypes.Values) {
				if(childType == type) {
					return true;
				}
			}
			return false;
		}
		[Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
		public IEnumerable GetChildrenNodes(ModelNode parentNode) {
			Guard.ArgumentNotNull(parentNode, "parentNode");
			List<object> result = new List<object>();
			if(parentNode.GetType().IsGenericType && parentNode.GetType().GetGenericTypeDefinition() == typeof(IModelList<>)) {
				return parentNode as IEnumerable;
			}
			if(parentNode.NodeInfo.ChildrenInfo != null) {
				ITypeInfo parentNodeTypeInfo = XafTypesInfo.Instance.FindTypeInfo(parentNode.GetType());
				foreach(NameTypeRect children in parentNode.NodeInfo.ChildrenInfo) {
					if(children.IsList) {
						return parentNode as IEnumerable;
					}
					IMemberInfo memberInfo = parentNodeTypeInfo.FindMember(children.Name);
					if(memberInfo != null) {
						if(IsChildrenVisible(parentNode, children.Name)) {
							object val = memberInfo.GetValue(parentNode);
							if(val != null) {
								result.Add(val);
							}
						}
					}
				}
			}
			return result;
		}
		private static bool IsChildVisible(ModelNode modelNode, NameTypeRect rect) {
			ITypeInfo ownerTypeInfo = XafTypesInfo.Instance.FindTypeInfo(rect.OwnerType);
			IMemberInfo memberInfo = ownerTypeInfo.FindMember(rect.Name);
			if(memberInfo != null) {
				IEnumerable<ModelBrowsableAttribute> modelBrowsableAttributes = memberInfo.FindAttributes<ModelBrowsableAttribute>();
				foreach(ModelBrowsableAttribute modelBrowsableAttribute in modelBrowsableAttributes) {
					Type visibilityCalculatorType = modelBrowsableAttribute.VisibilityCalculatorType;
					IModelIsVisible modelIsVisible = Activator.CreateInstance(visibilityCalculatorType) as IModelIsVisible;
					if(modelIsVisible != null && !modelIsVisible.IsVisible(modelNode, rect.Name)) {
						return false;
					}
				}
				BrowsableAttribute browsable = memberInfo.FindAttribute<BrowsableAttribute>();
				if(browsable != null && !browsable.Browsable) {
					return false;
				}
				return true;
			}
			return true;
		}
		internal static ModelNode[] GetChildNodes(ModelNode modelNode) {
			Guard.ArgumentNotNull(modelNode, "modelNode");
			Type nodeType = modelNode.NodeInfo.GeneratedClass;
			if(nodeType.IsGenericType && nodeType.GetGenericTypeDefinition() == typeof(IModelList<>)) {
				return modelNode.GetNodes();
			}
			if(modelNode.NodeInfo.ChildrenInfo != null) {
				List<ModelNode> result = new List<ModelNode>(modelNode.NodeInfo.ChildrenInfo.Count);
				foreach(NameTypeRect rect in modelNode.NodeInfo.ChildrenInfo) {
					if(rect.IsList) {
						return modelNode.GetNodes();
					}
					if(IsChildVisible(modelNode, rect)) {
						ModelNode childNode = modelNode.GetNode(rect.Name);
						if(childNode != null) {
							result.Add(childNode);
						}
					}
				}
				return result.ToArray();
			}
			return new ModelNode[0];
		}
		public void AddValidator<T>(IModelNodeValidator<T> validator) where T : IModelNode {
			Guard.ArgumentNotNull(validator, "validator");
			lock(TypesInfo.lockObject) {
				if(validators == null) {
					validators = new List<IModelNodeValidator>();
				}
				validators.Add(new TypedToUntypedModelNodeValidatorAdapter<T>(validator));
			}
		}
		[Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
		public void AddUpdater<T>(IModelNodeUpdater<T> updater) where T : IModelNode {
			Guard.ArgumentNotNull(updater, "updater");
			lock(TypesInfo.lockObject) {
				if(updaters == null) {
					updaters = new List<IModelNodeUpdater>();
				}
				updaters.Add(new TypedToUntypedModelNodeUpdaterAdapter<T>(updater));
			}
		}
		[Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
		public void ClearValidators() {
			lock(TypesInfo.lockObject) {
				validators = null;
			}
		}
		[Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
		public void ClearUpdaters() {
			lock(TypesInfo.lockObject) {
				updaters = null;
			}
		}
		[Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
		public bool IsValid(ModelNode node, IModelApplication application) {
			lock(TypesInfo.lockObject) {
				if(validators != null) {
					foreach(IModelNodeValidator validator in validators) {
						if(!validator.IsValid(node, application)) {
							return false;
						}
					}
				}
				return true;
			}
		}
		internal void Update(ModelNode modelNode, IModelApplication application) {
			lock(TypesInfo.lockObject) {
				if(updaters != null) {
					foreach(IModelNodeUpdater updater in updaters) {
						updater.UpdateNode(modelNode, application);
					}
				}
			}
		}
		private static bool IsChildrenVisible(ModelNode node, string propertyName) {
			ITypeInfo typeInfo = XafTypesInfo.Instance.FindTypeInfo(node.NodeInfo.GeneratedClass);
			foreach(ITypeInfo implementedInterface in typeInfo.ImplementedInterfaces) {
				foreach(IMemberInfo memberInfo in implementedInterface.Members) {
					if(memberInfo.Name == propertyName) {
						IEnumerable<ModelBrowsableAttribute> modelBrowsableAttributes = memberInfo.FindAttributes<ModelBrowsableAttribute>();
						foreach(ModelBrowsableAttribute modelBrowsableAttribute in modelBrowsableAttributes) {
							Type visibilityCalculatorType = modelBrowsableAttribute.VisibilityCalculatorType;
							IModelIsVisible modelIsVisible = Activator.CreateInstance(visibilityCalculatorType) as IModelIsVisible;
							if(modelIsVisible != null && !modelIsVisible.IsVisible(node, propertyName)) {
								return false;
							}
						}
						BrowsableAttribute browsable = memberInfo.FindAttribute<BrowsableAttribute>();
						if(browsable != null && !browsable.Browsable) {
							return false;
						}
						return true;
					}
				}
			}
			return true;
		}
		public enum ChildrenType { ListOnly, PropertyOnly, All }
		Dictionary<string, Type> GetChildrenTypes(ChildrenType childrenType) {
			if(ChildrenInfo == null) return EmptyStringTypeDictionary;
			if(this.allChildrenTypes == null) {
				this.allChildrenTypes = new Dictionary<string, Type>();
				foreach(NameTypeRect rect in ChildrenInfo) {
					string name = rect.IsList ? GetXmlNameByChildNodeType(rect.Type) : rect.Name;
					this.allChildrenTypes[name] = rect.Type;
					if(rect.IsList) {
						if(this.listChildrenTypes == null) {
							this.listChildrenTypes = new Dictionary<string, Type>();
						}
						this.listChildrenTypes[name] = rect.Type;
					}
					else {
						if(this.propertyChildrenTypes == null) {
							this.propertyChildrenTypes = new Dictionary<string, Type>();
						}
						this.propertyChildrenTypes[name] = rect.Type;
					}
				}
			}
			if(this.listChildrenTypes == null) {
				this.listChildrenTypes = EmptyStringTypeDictionary;
			}
			if(this.propertyChildrenTypes == null) {
				this.propertyChildrenTypes = EmptyStringTypeDictionary;
			}
			switch(childrenType) {
				case ChildrenType.PropertyOnly: return this.propertyChildrenTypes;
				case ChildrenType.ListOnly: return this.listChildrenTypes;
				default: return this.allChildrenTypes;
			}
		}
		private Type GetTypeByChildNodeName(string childNodeName, bool includeInList) {
			if(ChildrenInfo != null) {
				foreach(NameTypeRect rect in ChildrenInfo) {
					if(childNodeName == rect.Name && (includeInList || !rect.IsList)) {
						return rect.Type;
					}
				}
			}
			return null;
		}
		private string GetNameByChildNodeType(Type childNodeType, bool includeInList) {
			if(ChildrenInfo != null) {
				foreach(NameTypeRect rect in ChildrenInfo) {
					if(childNodeType == rect.Type && (includeInList || !rect.IsList)) {
						return rect.Name;
					}
				}
			}
			return null;
		}
		[Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
		public string GetValueNameByXmlName(string xmlName) {
			Guard.ArgumentNotNullOrEmpty(xmlName, "xmlName");
			if(XmlNames != null) {
				foreach(XmlNameRect rect in XmlNames) {
					if(string.Compare(rect.XmlName, xmlName, true) == 0) {
						return rect.Name;
					}
				}
			}
			return GetCaseInsensitiveValueName(xmlName);
		}
		[Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
		public string GetXmlNameByValueName(string name) {
			Guard.ArgumentNotNullOrEmpty(name, "name");
			if(XmlNames != null) {
				foreach(XmlNameRect rect in XmlNames) {
					if(rect.Name == name) {
						return rect.XmlName;
					}
				}
			}
			return name;
		}
		string GetCaseInsensitiveValueName(string name) {
			if(!valuesInfo.ContainsKey(name)) {
				if(String.Compare(KeyName, name, true) == 0) {
					return KeyName;
				}
				foreach(string valueName in valuesInfo.Keys) {
					if(String.Compare(valueName, name, true) == 0) {
						return valueName;
					}
				}
			}
			return name;
		}
		internal void UpdateNodes(IList<ModelNode> nodeLayers) {
			if(OnUpdateNodes != null) {
				OnUpdateNodes(nodeLayers);
			}
		}
		internal Action<IList<ModelNode>> OnUpdateNodes;
	}
	sealed class TypedToUntypedModelNodeUpdaterAdapter<T> : IModelNodeUpdater where T : IModelNode {
		readonly IModelNodeUpdater<T> updater;
		internal TypedToUntypedModelNodeUpdaterAdapter(IModelNodeUpdater<T> updater) {
			Guard.ArgumentNotNull(updater, "updater");
			this.updater = updater;
		}
		public void UpdateNode(IModelNode node, IModelApplication application) {
			updater.UpdateNode((T)node, application);
		}
		public override string ToString() {
			return string.Format("ModelNodeUpdaterAdapter: {0}", updater);
		}
	}
	sealed class TypedToUntypedModelNodeValidatorAdapter<T> : IModelNodeValidator where T : IModelNode {
		readonly IModelNodeValidator<T> validator;
		internal TypedToUntypedModelNodeValidatorAdapter(IModelNodeValidator<T> validator) {
			Guard.ArgumentNotNull(validator, "validator");
			this.validator = validator;
		}
		public bool IsValid(IModelNode node, IModelApplication application) {
			return validator.IsValid((T)node, application);
		}
		public override string ToString() {
			return string.Format("ModelNodeValidatorAdapter: {0}", validator);
		}
	}
}
